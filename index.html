-- ============================================
-- ✅ PATCH CONSOLIDADO (SEGURO, IDEMPOTENTE)
-- - Sem DROP TABLE / não apaga dados
-- - Cria/ajusta estruturas se não existirem
-- - HOTFIX usuarios_app.user_id + backfill + FK
-- - Helpers com SECURITY DEFINER + row_security=off
-- - RPCs (list_users, set_permissoes) com DROP seguro de versões antigas
-- - Habilita e FORÇA RLS
-- - Limpa policies antigas e recria as oficiais
-- ============================================

BEGIN;

-- ============================================================
-- 0) EXTENSÕES
-- ============================================================
CREATE EXTENSION IF NOT EXISTS pgcrypto;   -- gen_random_uuid()
-- CREATE EXTENSION IF NOT EXISTS citext;  -- opcional p/ email case-insensitive

-- ============================================================
-- 1) TABELAS (criar se não existirem)
-- ============================================================

-- 1.1) Permissões do app
CREATE TABLE IF NOT EXISTS public.permissoes_app (
  user_id uuid PRIMARY KEY,
  is_admin boolean NOT NULL DEFAULT false,
  perm_controle_diario boolean NOT NULL DEFAULT false,
  perm_consumo_total boolean NOT NULL DEFAULT false,
  granted_by uuid NULL,
  granted_at timestamptz NOT NULL DEFAULT now()
);

-- FK para auth.users (id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='permissoes_app_user_id_fkey'
  ) THEN
    ALTER TABLE public.permissoes_app
      ADD CONSTRAINT permissoes_app_user_id_fkey
      FOREIGN KEY (user_id) REFERENCES auth.users (id)
      ON UPDATE CASCADE ON DELETE CASCADE;
  END IF;
END$$;

-- Índices auxiliares
CREATE INDEX IF NOT EXISTS idx_permissoes_admin ON public.permissoes_app (is_admin);
CREATE INDEX IF NOT EXISTS idx_permissoes_flags ON public.permissoes_app (perm_controle_diario, perm_consumo_total);

-- 1.2) Perfil/usuários do app (usada pela UI)
CREATE TABLE IF NOT EXISTS public.usuarios_app (
  user_id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE,
  display_name text,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- ===== HOTFIX integrado: garantir user_id + backfill + FK =====
DO $$
BEGIN
  -- 1) Coluna user_id (se faltar)
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name='usuarios_app' AND column_name='user_id'
  ) THEN
    ALTER TABLE public.usuarios_app ADD COLUMN user_id uuid;
  END IF;

  -- 2) Backfill via email (case-insensitive), sem sobrescrever quem já tem
  UPDATE public.usuarios_app ua
  SET user_id = u.id
  FROM auth.users u
  WHERE ua.user_id IS NULL
    AND ua.email IS NOT NULL
    AND lower(ua.email) = lower(u.email);

  -- 3) Índice auxiliar
  IF NOT EXISTS (
    SELECT 1 FROM pg_class c
    JOIN pg_namespace n ON n.oid=c.relnamespace
    WHERE c.relkind='i' AND c.relname='idx_usuarios_app_user_id' AND n.nspname='public'
  ) THEN
    CREATE INDEX idx_usuarios_app_user_id ON public.usuarios_app(user_id);
  END IF;

  -- 4) FK (se faltar)
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname='usuarios_app_user_id_fkey'
  ) THEN
    ALTER TABLE public.usuarios_app
      ADD CONSTRAINT usuarios_app_user_id_fkey
      FOREIGN KEY (user_id) REFERENCES auth.users (id)
      ON UPDATE CASCADE ON DELETE SET NULL;
  END IF;
END$$;
-- ===== /HOTFIX integrado =====

-- ============================================================
-- 2) GRANTS BÁSICOS
-- ============================================================
GRANT USAGE ON SCHEMA public TO anon, authenticated;

GRANT SELECT, INSERT, UPDATE, DELETE ON public.permissoes_app TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.usuarios_app   TO authenticated;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='motoristas') THEN
    GRANT SELECT, INSERT, UPDATE, DELETE ON public.motoristas TO authenticated;
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='controle_diario') THEN
    GRANT SELECT, INSERT, UPDATE, DELETE ON public.controle_diario TO authenticated;
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='recargas_motoristas') THEN
    GRANT SELECT, INSERT, UPDATE, DELETE ON public.recargas_motoristas TO authenticated;
  END IF;
END$$;

-- ============================================================
-- 3) FUNÇÕES HELPER (SECURITY DEFINER + row_security=off)
-- ============================================================
CREATE OR REPLACE FUNCTION public.is_admin(uid uuid DEFAULT auth.uid())
RETURNS boolean
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public, pg_temp
SET row_security = off
AS $$
DECLARE v_uid uuid := COALESCE(uid, auth.uid()); v_is boolean;
BEGIN
  SELECT EXISTS(SELECT 1 FROM public.permissoes_app pa WHERE pa.user_id=v_uid AND pa.is_admin)
    INTO v_is;
  RETURN COALESCE(v_is, false);
END$$;

CREATE OR REPLACE FUNCTION public.has_perm_controle_diario(uid uuid DEFAULT auth.uid())
RETURNS boolean
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public, pg_temp
SET row_security = off
AS $$
DECLARE v_uid uuid := COALESCE(uid, auth.uid()); v_ok boolean;
BEGIN
  SELECT EXISTS(
    SELECT 1 FROM public.permissoes_app pa
    WHERE pa.user_id = v_uid AND (pa.is_admin OR pa.perm_controle_diario)
  ) INTO v_ok;
  RETURN COALESCE(v_ok, false);
END$$;

CREATE OR REPLACE FUNCTION public.has_perm_consumo_total(uid uuid DEFAULT auth.uid())
RETURNS boolean
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public, pg_temp
SET row_security = off
AS $$
DECLARE v_uid uuid := COALESCE(uid, auth.uid()); v_ok boolean;
BEGIN
  SELECT EXISTS(
    SELECT 1 FROM public.permissoes_app pa
    WHERE pa.user_id = v_uid AND (pa.is_admin OR pa.perm_consumo_total)
  ) INTO v_ok;
  RETURN COALESCE(v_ok, false);
END$$;

GRANT EXECUTE ON FUNCTION public.is_admin(uuid)                 TO authenticated, anon;
GRANT EXECUTE ON FUNCTION public.has_perm_controle_diario(uuid) TO authenticated, anon;
GRANT EXECUTE ON FUNCTION public.has_perm_consumo_total(uuid)   TO authenticated, anon;

-- ============================================================
-- 4) FUNÇÕES RPC (UI) — DROP seguro de versões antigas
-- ============================================================

-- 4.1) list_users — dropar qualquer variação e recriar
DO $$
DECLARE r record;
BEGIN
  FOR r IN
    SELECT n.nspname AS schema_name,
           p.proname AS fn_name,
           pg_get_function_identity_arguments(p.oid) AS args
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public'
      AND p.proname = 'list_users'
  LOOP
    EXECUTE format('DROP FUNCTION IF EXISTS %I.%I(%s);', r.schema_name, r.fn_name, r.args);
  END LOOP;
END$$;

CREATE OR REPLACE FUNCTION public.list_users()
RETURNS TABLE (
  user_id uuid,
  email text,
  last_sign_in_at timestamptz,
  created_at timestamptz
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public, auth, pg_temp
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'forbidden: admin required' USING ERRCODE = '42501';
  END IF;

  RETURN QUERY
    SELECT u.id, u.email, u.last_sign_in_at, u.created_at
    FROM auth.users u
    ORDER BY u.email NULLS LAST;
END$$;

COMMENT ON FUNCTION public.list_users() IS 'Lista usuários (auth.users). Restrito a admins.';
GRANT EXECUTE ON FUNCTION public.list_users() TO authenticated;

-- 4.2) set_permissoes — dropar qualquer variação e recriar
DO $$
DECLARE r record;
BEGIN
  FOR r IN
    SELECT n.nspname AS schema_name,
           p.proname AS fn_name,
           pg_get_function_identity_arguments(p.oid) AS args
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public'
      AND p.proname = 'set_permissoes'
  LOOP
    EXECUTE format('DROP FUNCTION IF EXISTS %I.%I(%s);', r.schema_name, r.fn_name, r.args);
  END LOOP;
END$$;

CREATE OR REPLACE FUNCTION public.set_permissoes(
  p_user_id uuid,
  p_perm_controle boolean,
  p_perm_consumo boolean,
  p_is_admin boolean
)
RETURNS void
LANGUAGE plpgsql
VOLATILE
SECURITY DEFINER
SET search_path = public, pg_temp
SET row_security = off
AS $$
BEGIN
  IF NOT public.is_admin() THEN
    RAISE EXCEPTION 'forbidden: admin required' USING ERRCODE = '42501';
  END IF;

  INSERT INTO public.permissoes_app AS pa
    (user_id, is_admin, perm_controle_diario, perm_consumo_total, granted_by, granted_at)
  VALUES
    (p_user_id, COALESCE(p_is_admin,false), COALESCE(p_perm_controle,false), COALESCE(p_perm_consumo,false), auth.uid(), now())
  ON CONFLICT (user_id) DO UPDATE
    SET is_admin             = EXCLUDED.is_admin,
        perm_controle_diario = EXCLUDED.perm_controle_diario,
        perm_consumo_total   = EXCLUDED.perm_consumo_total,
        granted_by           = EXCLUDED.granted_by,
        granted_at           = EXCLUDED.granted_at;
END$$;

COMMENT ON FUNCTION public.set_permissoes(uuid,boolean,boolean,boolean)
  IS 'Upsert de permissões. Restrito a admins.';
GRANT EXECUTE ON FUNCTION public.set_permissoes(uuid,boolean,boolean,boolean) TO authenticated;

-- ============================================================
-- 5) RLS: HABILITAR + FORÇAR
-- ============================================================
ALTER TABLE public.permissoes_app ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.usuarios_app   ENABLE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='motoristas') THEN
    EXECUTE 'ALTER TABLE public.motoristas ENABLE ROW LEVEL SECURITY';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='controle_diario') THEN
    EXECUTE 'ALTER TABLE public.controle_diario ENABLE ROW LEVEL SECURITY';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='recargas_motoristas') THEN
    EXECUTE 'ALTER TABLE public.recargas_motoristas ENABLE ROW LEVEL SECURITY';
  END IF;
END$$;

ALTER TABLE public.permissoes_app FORCE ROW LEVEL SECURITY;
ALTER TABLE public.usuarios_app   FORCE ROW LEVEL SECURITY;

DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='motoristas') THEN
    EXECUTE 'ALTER TABLE public.motoristas FORCE ROW LEVEL SECURITY';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='controle_diario') THEN
    EXECUTE 'ALTER TABLE public.controle_diario FORCE ROW LEVEL SECURITY';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='recargas_motoristas') THEN
    EXECUTE 'ALTER TABLE public.recargas_motoristas FORCE ROW LEVEL SECURITY';
  END IF;
END$$;

-- ============================================================
-- 6) LIMPEZA DE POLICIES ANTIGAS/PERMISSIVAS
-- ============================================================
DROP POLICY IF EXISTS recargas_read   ON public.recargas_motoristas;
DROP POLICY IF EXISTS recargas_write  ON public.recargas_motoristas;
DROP POLICY IF EXISTS recargas_update ON public.recargas_motoristas;

DO $$
DECLARE r record;
BEGIN
  FOR r IN
    SELECT schemaname, tablename, policyname
    FROM pg_policies
    WHERE schemaname='public'
      AND tablename IN ('permissoes_app','usuarios_app','motoristas','controle_diario','recargas_motoristas')
      AND policyname NOT IN (
        -- permissoes_app
        'permissoes_select_self_or_admin','permissoes_insert_self',
        'permissoes_update_admin','permissoes_delete_admin',
        -- usuarios_app
        'uapp_select_self_or_admin','uapp_insert_self','uapp_update_self_or_admin',
        -- motoristas
        'motoristas_select_all','motoristas_insert_perm','motoristas_update_perm','motoristas_delete_perm',
        -- controle_diario
        'cd_select_all','cd_insert_perm','cd_update_perm','cd_delete_perm',
        -- recargas_motoristas
        'recargas_select_perm','recargas_insert_perm','recargas_update_perm','recargas_delete_perm'
      )
  LOOP
    EXECUTE format('DROP POLICY %I ON public.%I', r.policyname, r.tablename);
  END LOOP;
END$$;

-- ============================================================
-- 7) POLICIES OFICIAIS (sem recursão)
-- ============================================================

-- 7.1) permissoes_app
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='permissoes_app' AND policyname='permissoes_select_self_or_admin'
  ) THEN
    CREATE POLICY permissoes_select_self_or_admin
    ON public.permissoes_app
    FOR SELECT TO authenticated
    USING (user_id = auth.uid() OR public.is_admin());
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='permissoes_app' AND policyname='permissoes_insert_self'
  ) THEN
    CREATE POLICY permissoes_insert_self
    ON public.permissoes_app
    FOR INSERT TO authenticated
    WITH CHECK (user_id = auth.uid());
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='permissoes_app' AND policyname='permissoes_update_admin'
  ) THEN
    CREATE POLICY permissoes_update_admin
    ON public.permissoes_app
    FOR UPDATE TO authenticated
    USING (public.is_admin())
    WITH CHECK (public.is_admin());
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='permissoes_app' AND policyname='permissoes_delete_admin'
  ) THEN
    CREATE POLICY permissoes_delete_admin
    ON public.permissoes_app
    FOR DELETE TO authenticated
    USING (public.is_admin());
  END IF;
END$$;

-- 7.2) usuarios_app (autogerenciável + admin)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='usuarios_app' AND policyname='uapp_select_self_or_admin'
  ) THEN
    CREATE POLICY uapp_select_self_or_admin
    ON public.usuarios_app
    FOR SELECT TO authenticated
    USING (
      email = (SELECT email FROM auth.users WHERE id = auth.uid())
      OR user_id = auth.uid()
      OR public.is_admin()
    );
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='usuarios_app' AND policyname='uapp_insert_self'
  ) THEN
    CREATE POLICY uapp_insert_self
    ON public.usuarios_app
    FOR INSERT TO authenticated
    WITH CHECK (
      email = (SELECT email FROM auth.users WHERE id = auth.uid())
      OR user_id = auth.uid()
    );
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='usuarios_app' AND policyname='uapp_update_self_or_admin'
  ) THEN
    CREATE POLICY uapp_update_self_or_admin
    ON public.usuarios_app
    FOR UPDATE TO authenticated
    USING (
      email = (SELECT email FROM auth.users WHERE id = auth.uid())
      OR user_id = auth.uid()
      OR public.is_admin()
    )
    WITH CHECK (
      email = (SELECT email FROM auth.users WHERE id = auth.uid())
      OR user_id = auth.uid()
      OR public.is_admin()
    );
  END IF;
END$$;

-- 7.3) motoristas — escrita só com perm_controle_diario (ou admin)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='motoristas') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='motoristas' AND policyname='motoristas_select_all') THEN
      CREATE POLICY motoristas_select_all
      ON public.motoristas
      FOR SELECT TO authenticated
      USING (true);
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='motoristas' AND policyname='motoristas_insert_perm') THEN
      CREATE POLICY motoristas_insert_perm
      ON public.motoristas
      FOR INSERT TO authenticated
      WITH CHECK (public.has_perm_controle_diario());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='motoristas' AND policyname='motoristas_update_perm') THEN
      CREATE POLICY motoristas_update_perm
      ON public.motoristas
      FOR UPDATE TO authenticated
      USING (public.has_perm_controle_diario())
      WITH CHECK (public.has_perm_controle_diario());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='motoristas' AND policyname='motoristas_delete_perm') THEN
      CREATE POLICY motoristas_delete_perm
      ON public.motoristas
      FOR DELETE TO authenticated
      USING (public.has_perm_controle_diario());
    END IF;
  END IF;
END$$;

-- 7.4) controle_diario — mesma regra de motoristas
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='controle_diario') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='controle_diario' AND policyname='cd_select_all') THEN
      CREATE POLICY cd_select_all
      ON public.controle_diario
      FOR SELECT TO authenticated
      USING (true);
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='controle_diario' AND policyname='cd_insert_perm') THEN
      CREATE POLICY cd_insert_perm
      ON public.controle_diario
      FOR INSERT TO authenticated
      WITH CHECK (public.has_perm_controle_diario());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='controle_diario' AND policyname='cd_update_perm') THEN
      CREATE POLICY cd_update_perm
      ON public.controle_diario
      FOR UPDATE TO authenticated
      USING (public.has_perm_controle_diario())
      WITH CHECK (public.has_perm_controle_diario());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='controle_diario' AND policyname='cd_delete_perm') THEN
      CREATE POLICY cd_delete_perm
      ON public.controle_diario
      FOR DELETE TO authenticated
      USING (public.has_perm_controle_diario());
    END IF;
  END IF;
END$$;

-- 7.5) recargas_motoristas — acesso restrito a consumo_total (ou admin)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='recargas_motoristas') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recargas_motoristas' AND policyname='recargas_select_perm') THEN
      CREATE POLICY recargas_select_perm
      ON public.recargas_motoristas
      FOR SELECT TO authenticated
      USING (public.has_perm_consumo_total());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recargas_motoristas' AND policyname='recargas_insert_perm') THEN
      CREATE POLICY recargas_insert_perm
      ON public.recargas_motoristas
      FOR INSERT TO authenticated
      WITH CHECK (public.has_perm_consumo_total());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recargas_motoristas' AND policyname='recargas_update_perm') THEN
      CREATE POLICY recargas_update_perm
      ON public.recargas_motoristas
      FOR UPDATE TO authenticated
      USING (public.has_perm_consumo_total())
      WITH CHECK (public.has_perm_consumo_total());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recargas_motoristas' AND policyname='recargas_delete_perm') THEN
      CREATE POLICY recargas_delete_perm
      ON public.recargas_motoristas
      FOR DELETE TO authenticated
      USING (public.has_perm_consumo_total());
    END IF;
  END IF;
END$$;

COMMIT;

-- ============================================================
-- 8) DIAGNÓSTICO (opcional)
-- ============================================================
-- SELECT tablename, policyname, cmd, roles
-- FROM pg_policies
-- WHERE schemaname='public'
--   AND tablename IN ('permissoes_app','usuarios_app','motoristas','controle_diario','recargas_motoristas')
-- ORDER BY tablename, policyname;
--
-- SELECT auth.uid(), public.is_admin() AS sou_admin,
--        public.has_perm_controle_diario() AS pode_controle,
--        public.has_perm_consumo_total()  AS pode_consumo;
--
-- Observações:
-- * No front, sempre usar a chave ANON + sessão do usuário.
-- * Chamadas com SERVICE ROLE ignoram RLS (apenas no backend confiável).
-- ============================================
-- FIM DO PATCH CONSOLIDADO
-- ============================================


/* =======================================================================
   ADD-ON: resolve_login_identifier(p_ident text) -> text (email)
   - NÃO altera o patch acima
   - Idempotente (drop seguro da função)
   - Permite login por "username" OU "email" no front
   ======================================================================= */

BEGIN;

-- Drop seguro de quaisquer versões antigas
DO $$
DECLARE r record;
BEGIN
  FOR r IN
    SELECT n.nspname AS schema_name,
           p.proname AS fn_name,
           pg_get_function_identity_arguments(p.oid) AS args
    FROM pg_proc p
    JOIN pg_namespace n ON n.oid = p.pronamespace
    WHERE n.nspname = 'public'
      AND p.proname = 'resolve_login_identifier'
  LOOP
    EXECUTE format('DROP FUNCTION IF EXISTS %I.%I(%s);', r.schema_name, r.fn_name, r.args);
  END LOOP;
END$$;

CREATE OR REPLACE FUNCTION public.resolve_login_identifier(p_ident text)
RETURNS text
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public, auth, pg_temp
SET row_security = off
AS $$
DECLARE
  v_ident text := trim(lower(p_ident));
  v_email text;
BEGIN
  IF v_ident IS NULL OR v_ident = '' THEN
    RETURN NULL;
  END IF;

  -- Se já parece e-mail, só normaliza
  IF v_ident LIKE '%@%._%' THEN
    RETURN v_ident;
  END IF;

  -- Resolver "username" -> e-mail (case-insensitive)
  SELECT lower(u.email)
    INTO v_email
    FROM public.usuarios_app ua
    JOIN auth.users u ON u.id = ua.user_id
   WHERE lower(ua.username) = v_ident
   LIMIT 1;

  RETURN v_email; -- pode ser NULL se não achar
END
$$;

COMMENT ON FUNCTION public.resolve_login_identifier(text)
  IS 'Resolve username ou email informado para um email válido de login. Usado na tela de login.';

GRANT EXECUTE ON FUNCTION public.resolve_login_identifier(text) TO anon, authenticated;

COMMIT;
