-- ============================================
-- ✅ PATCH CONSOLIDADO (SEGURO, IDEMPOTENTE)
-- - Não usa DROP TABLE
-- - Não recria tabelas existentes (só cria se não existirem)
-- - Não apaga dados
-- - Cria/ajusta funções RPC (list_users, set_permissoes)
-- - Endurece RLS (ENABLE + FORCE) nas tabelas do app
-- - Remove policies antigas/permissivas e recria as oficiais
-- - Concede permissões e EXECUTE nas funções necessárias
-- ============================================

BEGIN;

-- ============================================================
-- 0) EXTENSÕES E PREPAROS
-- ============================================================
CREATE EXTENSION IF NOT EXISTS pgcrypto;  -- gen_random_uuid()
-- Se quiser email case-insensitive em usuarios_app, descomente:
-- CREATE EXTENSION IF NOT EXISTS citext;

-- ============================================================
-- 1) TABELAS (criar se não existirem) + COLUNAS/ÍNDICES
-- ============================================================

-- 1.1) Tabela de permissões do app
CREATE TABLE IF NOT EXISTS public.permissoes_app (
  user_id uuid PRIMARY KEY,
  is_admin boolean NOT NULL DEFAULT false,
  perm_controle_diario boolean NOT NULL DEFAULT false,
  perm_consumo_total boolean NOT NULL DEFAULT false,
  granted_by uuid NULL,
  granted_at timestamptz NOT NULL DEFAULT now()
);

-- FK para auth.users (id)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname = 'permissoes_app_user_id_fkey'
  ) THEN
    ALTER TABLE public.permissoes_app
    ADD CONSTRAINT permissoes_app_user_id_fkey
    FOREIGN KEY (user_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE CASCADE;
  END IF;
END$$;

-- Índice auxiliar para buscas por admin
CREATE INDEX IF NOT EXISTS idx_permissoes_admin ON public.permissoes_app (is_admin);

-- 1.2) Tabela de perfis/usuarios do app (opcional, usada pela UI p/ mostrar nome)
CREATE TABLE IF NOT EXISTS public.usuarios_app (
  user_id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  email text UNIQUE,        -- troque para CITEXT se habilitar a extensão
  display_name text,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- FK usuários_app.user_id -> auth.users(id) (opcional, se você armazena o id do auth)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint WHERE conname = 'usuarios_app_user_id_fkey'
  ) THEN
    ALTER TABLE public.usuarios_app
    ADD CONSTRAINT usuarios_app_user_id_fkey
    FOREIGN KEY (user_id) REFERENCES auth.users (id) ON UPDATE CASCADE ON DELETE SET NULL;
  END IF;
END$$;

-- 1.3) Demais tabelas do app (assumimos que já existem):
-- public.motoristas
-- public.controle_diario
-- public.recargas_motoristas
-- Caso alguma não exista, crie-as aqui (sem apagar nada). Exemplos:
-- CREATE TABLE IF NOT EXISTS public.motoristas (
--   id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
--   nome text NOT NULL,
--   created_at timestamptz NOT NULL DEFAULT now()
-- );
-- CREATE TABLE IF NOT EXISTS public.controle_diario ( ... );
-- CREATE TABLE IF NOT EXISTS public.recargas_motoristas ( ... );

-- ============================================================
-- 2) GRANTS BÁSICOS (necessários para RLS funcionar com authenticated)
-- ============================================================
GRANT USAGE ON SCHEMA public TO anon, authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.permissoes_app      TO authenticated;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.usuarios_app        TO authenticated;
-- Se as tabelas abaixo existirem, garantimos os GRANTs também:
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='motoristas') THEN
    GRANT SELECT, INSERT, UPDATE, DELETE ON public.motoristas TO authenticated;
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='controle_diario') THEN
    GRANT SELECT, INSERT, UPDATE, DELETE ON public.controle_diario TO authenticated;
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='recargas_motoristas') THEN
    GRANT SELECT, INSERT, UPDATE, DELETE ON public.recargas_motoristas TO authenticated;
  END IF;
END$$;

-- ============================================================
-- 3) FUNÇÕES HELPER DE PERMISSÃO (SECURITY DEFINER + GRANT EXECUTE)
-- ============================================================
CREATE OR REPLACE FUNCTION public.has_perm_controle_diario()
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.permissoes_app pa
    WHERE pa.user_id = auth.uid()
      AND (pa.is_admin OR pa.perm_controle_diario)
  );
$$;

CREATE OR REPLACE FUNCTION public.has_perm_consumo_total()
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
SET search_path = public
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.permissoes_app pa
    WHERE pa.user_id = auth.uid()
      AND (pa.is_admin OR pa.perm_consumo_total)
  );
$$;

GRANT EXECUTE ON FUNCTION public.has_perm_controle_diario() TO authenticated, anon;
GRANT EXECUTE ON FUNCTION public.has_perm_consumo_total()  TO authenticated, anon;

-- ============================================================
-- 4) FUNÇÕES RPC (list_users, set_permissoes) — usadas pela UI
-- ============================================================

-- 4.1) list_users: retorna usuários do auth.users (apenas admin pode ver)
CREATE OR REPLACE FUNCTION public.list_users()
RETURNS TABLE (
  user_id uuid,
  email text,
  last_sign_in_at timestamptz,
  created_at timestamptz
)
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
SET search_path = public, auth
AS $$
BEGIN
  -- Verificação de admin
  IF NOT EXISTS (
    SELECT 1 FROM public.permissoes_app p
    WHERE p.user_id = auth.uid() AND p.is_admin
  ) THEN
    RAISE EXCEPTION 'forbidden: admin required' USING ERRCODE = '42501';
  END IF;

  RETURN QUERY
    SELECT u.id, u.email, u.last_sign_in_at, u.created_at
    FROM auth.users u
    ORDER BY u.email NULLS LAST;
END$$;

COMMENT ON FUNCTION public.list_users() IS 'Lista (id, email, last_sign_in_at, created_at) de auth.users. Restrito a admins.';
GRANT EXECUTE ON FUNCTION public.list_users() TO authenticated;

-- 4.2) set_permissoes: cria/ajusta flags de um usuário (apenas admin)
CREATE OR REPLACE FUNCTION public.set_permissoes(
  p_user_id uuid,
  p_perm_controle boolean,
  p_perm_consumo boolean,
  p_is_admin boolean
)
RETURNS void
LANGUAGE plpgsql
VOLATILE
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Verificação de admin
  IF NOT EXISTS (
    SELECT 1 FROM public.permissoes_app p
    WHERE p.user_id = auth.uid() AND p.is_admin
  ) THEN
    RAISE EXCEPTION 'forbidden: admin required' USING ERRCODE = '42501';
  END IF;

  INSERT INTO public.permissoes_app AS pa (user_id, is_admin, perm_controle_diario, perm_consumo_total, granted_by, granted_at)
  VALUES (p_user_id, COALESCE(p_is_admin,false), COALESCE(p_perm_controle,false), COALESCE(p_perm_consumo,false), auth.uid(), now())
  ON CONFLICT (user_id) DO UPDATE
    SET is_admin            = EXCLUDED.is_admin,
        perm_controle_diario= EXCLUDED.perm_controle_diario,
        perm_consumo_total  = EXCLUDED.perm_consumo_total,
        granted_by          = EXCLUDED.granted_by,
        granted_at          = EXCLUDED.granted_at;
END$$;

COMMENT ON FUNCTION public.set_permissoes(uuid,boolean,boolean,boolean) IS 'Upsert de permissões do app. Restrito a admins.';
GRANT EXECUTE ON FUNCTION public.set_permissoes(uuid,boolean,boolean,boolean) TO authenticated;

-- ============================================================
-- 5) RLS: HABILITAR + FORÇAR (FORCE) NAS TABELAS
-- ============================================================
ALTER TABLE public.permissoes_app      ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.usuarios_app        ENABLE ROW LEVEL SECURITY;
-- As três abaixo só se existirem:
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='motoristas') THEN
    EXECUTE 'ALTER TABLE public.motoristas ENABLE ROW LEVEL SECURITY';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='controle_diario') THEN
    EXECUTE 'ALTER TABLE public.controle_diario ENABLE ROW LEVEL SECURITY';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='recargas_motoristas') THEN
    EXECUTE 'ALTER TABLE public.recargas_motoristas ENABLE ROW LEVEL SECURITY';
  END IF;
END$$;

ALTER TABLE public.permissoes_app      FORCE ROW LEVEL SECURITY;
ALTER TABLE public.usuarios_app        FORCE ROW LEVEL SECURITY;
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='motoristas') THEN
    EXECUTE 'ALTER TABLE public.motoristas FORCE ROW LEVEL SECURITY';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='controle_diario') THEN
    EXECUTE 'ALTER TABLE public.controle_diario FORCE ROW LEVEL SECURITY';
  END IF;
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='recargas_motoristas') THEN
    EXECUTE 'ALTER TABLE public.recargas_motoristas FORCE ROW LEVEL SECURITY';
  END IF;
END$$;

-- ============================================================
-- 6) LIMPEZA DE POLICIES ANTIGAS/PERMISSIVAS
--    (mantém apenas o conjunto oficial abaixo)
-- ============================================================

-- Alguns nomes comuns de policies antigas em recargas:
DROP POLICY IF EXISTS recargas_read   ON public.recargas_motoristas;
DROP POLICY IF EXISTS recargas_write  ON public.recargas_motoristas;
DROP POLICY IF EXISTS recargas_update ON public.recargas_motoristas;

-- Remoção de qualquer outra policy fora do conjunto oficial
DO $$
DECLARE
  r record;
BEGIN
  FOR r IN
    SELECT schemaname, tablename, policyname
    FROM pg_policies
    WHERE schemaname='public'
      AND tablename IN ('permissoes_app','usuarios_app','motoristas','controle_diario','recargas_motoristas')
      AND policyname NOT IN (
        -- permissoes_app
        'permissoes_select_self_or_admin','permissoes_insert_self',
        'permissoes_update_admin','permissoes_delete_admin',
        -- usuarios_app
        'uapp_select_self_or_admin','uapp_insert_self','uapp_update_self_or_admin',
        -- motoristas
        'motoristas_select_all','motoristas_insert_perm','motoristas_update_perm','motoristas_delete_perm',
        -- controle_diario
        'cd_select_all','cd_insert_perm','cd_update_perm','cd_delete_perm',
        -- recargas_motoristas
        'recargas_select_perm','recargas_insert_perm','recargas_update_perm','recargas_delete_perm'
      )
  LOOP
    EXECUTE format('DROP POLICY %I ON public.%I', r.policyname, r.tablename);
  END LOOP;
END$$;

-- ============================================================
-- 7) POLICIES OFICIAIS (cria apenas se não existirem)
-- ============================================================

-- 7.1) permissoes_app
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='permissoes_app' AND policyname='permissoes_select_self_or_admin') THEN
    CREATE POLICY permissoes_select_self_or_admin
    ON public.permissoes_app
    FOR SELECT TO authenticated
    USING (
      user_id = auth.uid()
      OR EXISTS (SELECT 1 FROM public.permissoes_app p WHERE p.user_id = auth.uid() AND p.is_admin)
    );
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='permissoes_app' AND policyname='permissoes_insert_self') THEN
    CREATE POLICY permissoes_insert_self
    ON public.permissoes_app
    FOR INSERT TO authenticated
    WITH CHECK (user_id = auth.uid());
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='permissoes_app' AND policyname='permissoes_update_admin') THEN
    CREATE POLICY permissoes_update_admin
    ON public.permissoes_app
    FOR UPDATE TO authenticated
    USING (EXISTS (SELECT 1 FROM public.permissoes_app p WHERE p.user_id = auth.uid() AND p.is_admin))
    WITH CHECK (EXISTS (SELECT 1 FROM public.permissoes_app p WHERE p.user_id = auth.uid() AND p.is_admin));
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='permissoes_app' AND policyname='permissoes_delete_admin') THEN
    CREATE POLICY permissoes_delete_admin
    ON public.permissoes_app
    FOR DELETE TO authenticated
    USING (EXISTS (SELECT 1 FROM public.permissoes_app p WHERE p.user_id = auth.uid() AND p.is_admin));
  END IF;
END$$;

-- 7.2) usuarios_app (usuário lê/insere/atualiza o próprio; admin pode tudo)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='usuarios_app' AND policyname='uapp_select_self_or_admin') THEN
    CREATE POLICY uapp_select_self_or_admin
    ON public.usuarios_app
    FOR SELECT TO authenticated
    USING (
      email = (select email from auth.users where id = auth.uid())
      OR EXISTS (SELECT 1 FROM public.permissoes_app p WHERE p.user_id = auth.uid() AND p.is_admin)
    );
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='usuarios_app' AND policyname='uapp_insert_self') THEN
    CREATE POLICY uapp_insert_self
    ON public.usuarios_app
    FOR INSERT TO authenticated
    WITH CHECK (
      email = (select email from auth.users where id = auth.uid())
      OR user_id = auth.uid()
    );
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='usuarios_app' AND policyname='uapp_update_self_or_admin') THEN
    CREATE POLICY uapp_update_self_or_admin
    ON public.usuarios_app
    FOR UPDATE TO authenticated
    USING (
      email = (select email from auth.users where id = auth.uid())
      OR user_id = auth.uid()
      OR EXISTS (SELECT 1 FROM public.permissoes_app p WHERE p.user_id = auth.uid() AND p.is_admin)
    )
    WITH CHECK (
      email = (select email from auth.users where id = auth.uid())
      OR user_id = auth.uid()
      OR EXISTS (SELECT 1 FROM public.permissoes_app p WHERE p.user_id = auth.uid() AND p.is_admin)
    );
  END IF;
END$$;

-- 7.3) motoristas (leitura livre para autenticados; escrita só com perm_controle_diario ou admin)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='motoristas') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='motoristas' AND policyname='motoristas_select_all') THEN
      CREATE POLICY motoristas_select_all
      ON public.motoristas
      FOR SELECT TO authenticated
      USING (true);
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='motoristas' AND policyname='motoristas_insert_perm') THEN
      CREATE POLICY motoristas_insert_perm
      ON public.motoristas
      FOR INSERT TO authenticated
      WITH CHECK (public.has_perm_controle_diario());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='motoristas' AND policyname='motoristas_update_perm') THEN
      CREATE POLICY motoristas_update_perm
      ON public.motoristas
      FOR UPDATE TO authenticated
      USING (public.has_perm_controle_diario())
      WITH CHECK (public.has_perm_controle_diario());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='motoristas' AND policyname='motoristas_delete_perm') THEN
      CREATE POLICY motoristas_delete_perm
      ON public.motoristas
      FOR DELETE TO authenticated
      USING (public.has_perm_controle_diario());
    END IF;
  END IF;
END$$;

-- 7.4) controle_diario (mesma lógica de motoristas)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='controle_diario') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='controle_diario' AND policyname='cd_select_all') THEN
      CREATE POLICY cd_select_all
      ON public.controle_diario
      FOR SELECT TO authenticated
      USING (true);
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='controle_diario' AND policyname='cd_insert_perm') THEN
      CREATE POLICY cd_insert_perm
      ON public.controle_diario
      FOR INSERT TO authenticated
      WITH CHECK (public.has_perm_controle_diario());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='controle_diario' AND policyname='cd_update_perm') THEN
      CREATE POLICY cd_update_perm
      ON public.controle_diario
      FOR UPDATE TO authenticated
      USING (public.has_perm_controle_diario())
      WITH CHECK (public.has_perm_controle_diario());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='controle_diario' AND policyname='cd_delete_perm') THEN
      CREATE POLICY cd_delete_perm
      ON public.controle_diario
      FOR DELETE TO authenticated
      USING (public.has_perm_controle_diario());
    END IF;
  END IF;
END$$;

-- 7.5) recargas_motoristas (leitura e escrita restritas a perm_consumo_total ou admin)
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='recargas_motoristas') THEN
    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recargas_motoristas' AND policyname='recargas_select_perm') THEN
      CREATE POLICY recargas_select_perm
      ON public.recargas_motoristas
      FOR SELECT TO authenticated
      USING (public.has_perm_consumo_total());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recargas_motoristas' AND policyname='recargas_insert_perm') THEN
      CREATE POLICY recargas_insert_perm
      ON public.recargas_motoristas
      FOR INSERT TO authenticated
      WITH CHECK (public.has_perm_consumo_total());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recargas_motoristas' AND policyname='recargas_update_perm') THEN
      CREATE POLICY recargas_update_perm
      ON public.recargas_motoristas
      FOR UPDATE TO authenticated
      USING (public.has_perm_consumo_total())
      WITH CHECK (public.has_perm_consumo_total());
    END IF;

    IF NOT EXISTS (SELECT 1 FROM pg_policies WHERE schemaname='public' AND tablename='recargas_motoristas' AND policyname='recargas_delete_perm') THEN
      CREATE POLICY recargas_delete_perm
      ON public.recargas_motoristas
      FOR DELETE TO authenticated
      USING (public.has_perm_consumo_total());
    END IF;
  END IF;
END$$;

COMMIT;

-- ============================================================
-- 8) DIAGNÓSTICO RÁPIDO (opcional)
-- ============================================================
-- SELECT tablename, policyname, cmd, roles
-- FROM pg_policies
-- WHERE schemaname='public'
--   AND tablename IN ('permissoes_app','usuarios_app','motoristas','controle_diario','recargas_motoristas')
-- ORDER BY tablename, policyname;

-- Notas importantes:
-- * Se alguém ainda conseguir escrever sem permissão, verifique se a chamada
--   está usando a chave SERVICE ROLE (service_role). Ela ignora RLS.
-- * No front, sempre usar a chave ANON + sessão do usuário autenticado.
-- * A UI de permissões (modal) usa public.list_users e public.set_permissoes.

-- ============================================
-- FIM DO PATCH CONSOLIDADO
-- ============================================
